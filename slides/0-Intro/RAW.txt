


The main goal of this workshop is to create & deploy a full-stack application with some of my favourite tools that make this as easy as possible.
By the end you will each own a fully deployed website; including auth, a database, and of course the site itself.
I’ve split today into several iterative challenges that break this down into smaller pieces.
There are bonus challenges for more advanced concepts.


What are we going to do?
Hopefully you all know roughly what you’ve signed up for
We’ll be building a fullstack website from scratch that includes auth, a database and some basic CRUD operations using a tech stack that provides one of the best developer experiences I’ve ever used.
The website we’ll build will be about posting “recipes” and viewing your own recipes. If you have your own idea for a site you want to do that is similar in technical requirements, by all means go for that. Or adapting the recipes website will be straightforward enough.
Now I dont like presenting very much so unluckily for you this workshop is gonna mostly be you guys coding stuff and me cracking the whip

TECHNOLOGIES
NextAuth
Tailwind CSS
Next JS
Prisma
Typescript
Whether you’re new to web development or a seasoned pro, the “strictness” of TypeScript will provide a less frustrating, more consistent experience than vanilla JS.
Prisma is to SQL what TypeScript is to JS. It created a developer experience that didn’t exist before. By generating types from a user-defined schema compatible with several databases, Prisma guarantees end-to-end typesafety from your database to your app.
T3 Stack
Next.js offers a lightly opinionated, heavily optimized approach to creating applications using React. From routing to API definitions to image rendering, we trust Next.js to lead developers toward good decisions.
An excellent solution to bring in the complexity of security without the hassle of having to build it yourself. It comes with an extensive list of providers to quickly add OAuth authentication and provides adapters for many databases and ORMs.
Tailwind feels like “zen-mode CSS”. 
By providing building blocks in the form of good default colors, spacing, and other primitives, Tailwind makes it easy to create a good-looking app. And unlike component libraries, it does not hold you back when you want to take your app to the next level and create something beautiful and unique.

T3 Stack made by Theo - t3.gg

Opinionated tech stack, but arguably provides one of the best developer experiences I have ever used

TECHNOLOGIES
NextAuth
Tailwind CSS
Next JS
Prisma
Typescript
Whether you’re new to web development or a seasoned pro, the “strictness” of TypeScript will provide a less frustrating, more consistent experience than vanilla JS.
Prisma is to SQL what TypeScript is to JS. It created a developer experience that didn’t exist before. By generating types from a user-defined schema compatible with several databases, Prisma guarantees end-to-end typesafety from your database to your app.
T3 Stack
Next.js offers a lightly opinionated, heavily optimized approach to creating applications using React. From routing to API definitions to image rendering, we trust Next.js to lead developers toward good decisions.
An excellent solution to bring in the complexity of security without the hassle of having to build it yourself. It comes with an extensive list of providers to quickly add OAuth authentication and provides adapters for many databases and ORMs.
Tailwind feels like “zen-mode CSS”. 
By providing building blocks in the form of good default colors, spacing, and other primitives, Tailwind makes it easy to create a good-looking app. And unlike component libraries, it does not hold you back when you want to take your app to the next level and create something beautiful and unique.

Hopefully we’ve all used Next JS a bit, if you’ve not then it’s just another JavaScript Framework that uses React to provide a lightly opinionated heavily optimized experience.
We will be using Next 14 which has some pretty significant changes over Next 12 which we used on TCO
Anyone used the new version yet?

TECHNOLOGIES
NextAuth
Tailwind CSS
Next JS
Prisma
Typescript
Whether you’re new to web development or a seasoned pro, the “strictness” of TypeScript will provide a less frustrating, more consistent experience than vanilla JS.
Prisma is to SQL what TypeScript is to JS. It created a developer experience that didn’t exist before. By generating types from a user-defined schema compatible with several databases, Prisma guarantees end-to-end typesafety from your database to your app.
T3 Stack
Next.js offers a lightly opinionated, heavily optimized approach to creating applications using React. From routing to API definitions to image rendering, we trust Next.js to lead developers toward good decisions.
An excellent solution to bring in the complexity of security without the hassle of having to build it yourself. It comes with an extensive list of providers to quickly add OAuth authentication and provides adapters for many databases and ORMs.
Tailwind feels like “zen-mode CSS”. 
By providing building blocks in the form of good default colors, spacing, and other primitives, Tailwind makes it easy to create a good-looking app. And unlike component libraries, it does not hold you back when you want to take your app to the next level and create something beautiful and unique.

Prisma is in my opinion the best ORM I’ve ever used in terms of DX
Really good for maintaining type safety with your queries, and is great for its explorability so you can find what query operations you need

TECHNOLOGIES
NextAuth
Tailwind CSS
Next JS
Prisma
Typescript
Whether you’re new to web development or a seasoned pro, the “strictness” of TypeScript will provide a less frustrating, more consistent experience than vanilla JS.
Prisma is to SQL what TypeScript is to JS. It created a developer experience that didn’t exist before. By generating types from a user-defined schema compatible with several databases, Prisma guarantees end-to-end typesafety from your database to your app.
T3 Stack
Next.js offers a lightly opinionated, heavily optimized approach to creating applications using React. From routing to API definitions to image rendering, we trust Next.js to lead developers toward good decisions.
An excellent solution to bring in the complexity of security without the hassle of having to build it yourself. It comes with an extensive list of providers to quickly add OAuth authentication and provides adapters for many databases and ORMs.
Tailwind feels like “zen-mode CSS”. 
By providing building blocks in the form of good default colors, spacing, and other primitives, Tailwind makes it easy to create a good-looking app. And unlike component libraries, it does not hold you back when you want to take your app to the next level and create something beautiful and unique.

I dont think many or any will have used NextAuth before, but it simply takes a lot of the burden away from you for authentication and authorisation in your Next JS app.

Using a config object you define what providers like Google SSO, username/password, or Discord you want, as well as session based auth vs jwts.

TECHNOLOGIES
NextAuth
Tailwind CSS
Next JS
Prisma
Typescript
Whether you’re new to web development or a seasoned pro, the “strictness” of TypeScript will provide a less frustrating, more consistent experience than vanilla JS.
Prisma is to SQL what TypeScript is to JS. It created a developer experience that didn’t exist before. By generating types from a user-defined schema compatible with several databases, Prisma guarantees end-to-end typesafety from your database to your app.
T3 Stack
Next.js offers a lightly opinionated, heavily optimized approach to creating applications using React. From routing to API definitions to image rendering, we trust Next.js to lead developers toward good decisions.
An excellent solution to bring in the complexity of security without the hassle of having to build it yourself. It comes with an extensive list of providers to quickly add OAuth authentication and provides adapters for many databases and ORMs.
Tailwind feels like “zen-mode CSS”. 
By providing building blocks in the form of good default colors, spacing, and other primitives, Tailwind makes it easy to create a good-looking app. And unlike component libraries, it does not hold you back when you want to take your app to the next level and create something beautiful and unique.

Its a bit like marmite in that some people love it, others hate it.
It’s a lightweight utility CSS library that essentially provides shorthand inline CSS that forces you to take ownership of the styling of your app rather than things like MaterialUI.
Definitely takes some getting used to, and in my opinion only good for greenfield projects but once you’re used to it I definitely really enjoy it



TECHNOLOGIES
NextAuth
Tailwind CSS
Next JS
Prisma
Typescript
Whether you’re new to web development or a seasoned pro, the “strictness” of TypeScript will provide a less frustrating, more consistent experience than vanilla JS.
Prisma is to SQL what TypeScript is to JS. It created a developer experience that didn’t exist before. By generating types from a user-defined schema compatible with several databases, Prisma guarantees end-to-end typesafety from your database to your app.
T3 Stack
Next.js offers a lightly opinionated, heavily optimized approach to creating applications using React. From routing to API definitions to image rendering, we trust Next.js to lead developers toward good decisions.
An excellent solution to bring in the complexity of security without the hassle of having to build it yourself. It comes with an extensive list of providers to quickly add OAuth authentication and provides adapters for many databases and ORMs.
Tailwind feels like “zen-mode CSS”. 
By providing building blocks in the form of good default colors, spacing, and other primitives, Tailwind makes it easy to create a good-looking app. And unlike component libraries, it does not hold you back when you want to take your app to the next level and create something beautiful and unique.

TypeScript is very much the essence of the T3 stack. One of the quotes that sticks with me from the author, Theo is “Build guardrails not safety nets”.
This means build tools that force you to code the correct behaviour, rather than say e2e tests to catch your mistakes after you’ve built it.
TypeScript is a fantastic guardrail and its to the point where you could remove say an “email” column from your “user” table, and if somewhere in your codebase fetches all users, and your frontend tries to render the email column, your build will fail. Rather than you having to QA the site or run a suite of e2e tests you reduce the feedback loop significantly.

CHALLENGES
Creating & configuring an app using create t3-app
Deploying this to Vercel along with Vercel storage
Configuring SSO via Google Cloud and Next Auth
Replacing the default T3 app root page with a login page
Adding a page that lists all of a user’s recipes
Allowing the user to add additional recipes using server actions

Run the command yarn create t3-app and enter the following options:
Project name
Use Typescript? Yes
Use Tailwind? Yes
Use tRPC? No
Auth provider? NextAuth
Database ORM? Prisma
Use App Router? Yes
Database provider? PostgreSQL
Init git? Yes
Run yarn? Yes
Import alias? Just hit enter
Challenge 1: Create t3-app
Once its setup, try and run yarn build.

You will see errors around env variables. Builds will fail if you forget to include any required environment variables.

Supply your database credentials, and random next auth secret. 

For now we will remove the Discord env variables, and references to them by removing the provider from the NextAuth config.

Build the app, and start it up to see the default T3 page!

Challenge 2: Vercel
Best practice is to deploy apps as soon as possible, and at this stage we have a locally running application. So lets deploy it! We will be using Vercel, which takes away a lot of the pain of infrastructure, and under the hood configures AWS perfectly for a NextJS project.
We will also use Vercel Storage to host our database.
Deploy site to Vercel
https://vercel.com/dashboard
Set up a personal account with vercel 
Add new project
Link your github account where you committed your project to
Import the project
Add all the needed env vars (except for your DB env vars)
Deploy database to Vercel Storage
https://vercel.com/dashboard/stores
Create a PostgreSQL database
Update your schema.prisma file with the provided snippet vercel gives you
Update your DB env vars locally
Comment out your local DB env var values and add in your production values
Run yarn db:push to update vercels  database with your schema
Deploy the site!

Under the hood - Vercel is just AWS. This is roughly what it spins up, bar the warmer function and of course including a database too.
If you’re going to production, its of course cheaper to build this in AWS yourself. But if you use Vercel the extra you’re paying is for the ease of use and support of Nexts cutting edge features.
As you can work out its architecture is serverless, and relies on AWS lambdas, buckets, and a CDN with cloudfront all configured together nicely.

Challenge 3: Google Cloud SSO & Next Auth
Now that we have a fully deployed app & database, let’s add the next piece of the puzzle. NextAuth accepts a range of SSO providers, for this workshop we will be using Google Cloud.
Set up an OAuth consent screen: https://developers.google.com/workspace/guides/configure-oauth-consent
Create OAuth client credentials https://developers.google.com/workspace/guides/create-credentials#web-application
Authorized JavaScript Origins
https://<vercel-website>
http://localhost:3000
http://localhost
Authorized redirect urls
https://<vercel-website>/api/auth/callback/google
http://localhost:3000/api/auth/callback/google
Copy the client ID and secret into your env vars
Add a NextAuth provider for Google in src/server/auth.ts
Deploy your changes!
Consider alternative login component?

Setting Up Your Environment

Node.js is a JavaScript runtime that enables executing JavaScript on the server. npm, the Node Package Manager, is essential for managing dependencies and packages in your projects.

Download Node.js: Visit the official Node.js website and download the latest Long Term Support (LTS) version suitable for your operating system.

Install Node.js and npm: Follow the installation instructions provided on the website.

Verify the installation by running node -v and npm -v in your terminal. Node.js brings JavaScript to the server-side, and npm streamlines the process of managing libraries and packages.
Node.js and NPM

npm comes bundled with Node.js and is the default package manager.

Yarn, an alternative package manager, offers improvements in performance and reliability.

npm: Use npm install <package-name> to install packages. For example, npm install react.
Package Managers

A code editor is your workspace for creating React applications. Visual Studio Code (VS Code) is a popular choice for its versatility and extensive support for React development.

Download VS Code: Visit Visual Studio Code's official website to download and install the latest version suitable for your operating system.

Extensions for React: Enhance your React development experience by installing extensions like "ESLint," "Prettier," and "Reactjs code snippets."

VS Code provides a lightweight yet powerful environment for coding and debugging.
Code Editors

Create React App (CRA) is a tool that automates the process of setting up a new React project with a predefined structure and configurations.

Install CRA: Open your terminal and run npx create-react-app my-app to create a new React project named "my-app."

Project Structure: CRA establishes a standardized project structure, including folders for source code (src), public assets (public), and configuration files. CRA simplifies the initial setup, letting you focus on building your application.
Create React App

A well-organized folder structure is crucial for maintaining a scalable and maintainable React application.

src Folder: The src folder contains your application's source code, where React components, styles, and other assets are located.

public Folder: The public folder holds static assets like HTML files, images, and other resources that don't require processing by Webpack.

The clear separation of concerns in the folder structure promotes code organization.
Folder Structure

Once your React app is set up, it's time to run it and preview your application in a development environment.

Navigate to Project Directory: In your terminal, change the directory to your project using cd my-app (replace "my-app" with your actual project name).

Start Development Server: Run npm start or yarn start to launch the development server.

Open Your Browser: Visit http://localhost:3000 in your web browser to view your React app. The development server provides real-time updates and a hot-reloading feature for efficient development.
Running Your App

The package.json file contains scripts that automate common tasks in your React project.

npm start: Launches the development server, providing a live preview of your app at http://localhost:3000.

npm build: Builds a production-ready version of your app, optimizing it for performance and reducing file sizes.

npm test: Executes test suites using Jest, the default testing framework for Create React App. Explore other scripts for tasks such as linting, formatting, and custom configurations.
Understanding NPM

Q&A

So, any questions?
Q&A

RSC example
RSC
GetServerSideProps
Typescript: Inference over manual declaration. Guaranteed safety rather than ownership of the developer to get it right
10 lines of code less
Your async requests could be nested inside RecipeList rather than at the top of the page.

RSC limitations
The only limitation of RSC’s is that you cannot use client side JavaScript that runs in the browser.

Things like event handlers (onClick, onMouseDown), react hooks (useState, useEffect), or other browser APIs (local storage, geolocation) are not possible and you will get a build error if you attempt to do this.

This is where Client Components come into play. These are components where you can execute client side JavaScript. But since these run in the client, you cannot access server env vars or fetch from the data layer directly. 

Another caveat of Client Components is that all other
modules imported into it, including child components, are
considered part of the client bundle. This means you
cannot nest RSC’s within Client components.

I consider it best practice to try and keep your
client components at the bottom of your React
Component Tree for that reason.

To create a Client Component, you must use the
“use client” directive at the top of the file, above
your imports.


RSC’s probably sound really good right now. But whats the catch?
Well since they are rendered on the server at request time, you do not have access to client side javascript or browser APIs.
Things like useState, useEffect, event handlers like onClick are not supported and will fail the build if you try to use them from a server component.
This is where client components come in. They do not get the benefits of RSC’s like being able to perform async requests, but can use client side JS & browser APIs.
You must use the “use client” directive to make a client component. This defines a “boundary” that says this component AND any children of it are part of the client bundle.
This means you cannot nest RSC’s inside of client components, as its part of the client bundle.

Challenge 4: RSC & Client components
Now that all of our infrastructure is set up, we can finally start working on the site itself!
Remove the content in the default root page
Add a sign in button using NextAuth that redirects to the same page
If you have a session, render a sign out button instead
Deploy!
We’ll need to make use of some NextAuth functions, and React server/client components to do this properly

Challenge 4 bonus: Middleware
NextAuth provides a preconfigured Next middleware function that you can export to require authentication on different routes.
Unfortunately one of NextAuths constraints is that its middleware requires a JWT session rather than database (the default), so we need to change our NextAuth config to include the following:
 session: {
   strategy: "jwt",
 },
 callbacks: {
   session: ({ session, token }) => ({
     ...session,
     user: {
       ...session.user,
       id: token.sub,
     },
   }),
 },


Next app router


Now we’re going to need to understand the app router format a bit with Next 14 which is also pretty different from Next 12.
You have several page “types” such as layout, error, loading & page. These all do unique things.
Layout is some shared html thats rendered on each child page.
Error wraps its children in an ErrorBoundary that renders a fallback if an error is encountered
Loading wraps its children in a SuspenseBoundary that renders a fallback while its children perform async requests
And finally page is what you expect, a page that you can reference from your browser

Challenge 5: Prisma
Now that we have auth fully setup, let’s set up our app so we can fetch all of a user’s recipes.
First we need to define our database schema to support this table. There should be a default “Post” table you can modify for this. Make sure you run yarn install to update your prisma types, & yarn db:push (against your local database) to update your database.
Manually insert some test data (Tip: run yarn db:studio), and make a Next page to fetch the current user’s recipes and display them in a list.
Once you’re happy make sure to update your production database and code with the latest changes!
See if you can add some test data to the production environment as well.

Challenge 5 bonus: Suspense
We have effectively designed our page in a similar manner to GetServerSideProps in terms of the async requests all being blocking requests.
Another new feature of React 18 is React <Suspense>. We can wrap async React Server Components in <Suspense>, and provide a loading fallback UI that is rendered whilst the nested async requests are being processed. As soon as the requests finish, the fallback is swapped out with the children supplied to <Suspense>.
Next allows us to wrap entire pages in suspense using a Loading.tsx file, or we can wrap individual components in <Suspense> ourselves. I prefer the latter as this gives you more granularity on your suspense boundaries.
Under the hood this works by react splitting the html into a chunk per RSC, and streaming them to the clients device.


Challenge 6: Server Actions
Another significant change with Next 14 is the concept of Server Actions.
A Server Action is a function that only executes on the server, which we bind to a form using its action property. Where we might have submitted to an API endpoint in previous versions of Next, now we can simply supply a function that receives the forms data upon submission.
Since the Server Action runs on the server, we can directly update the database, or use any other async behaviour like calling APIs.
Our Server Actions can even return values that our form can then receive, which allows us to very easily set up server side validation without ever needing client side javascript to be enabled.
A server action is defined when we use the “use server” directive. You can place the directive at the top of an async function to mark the function as a Server Action, or at the top of a separate file to mark all exports of that file as Server Actions. 
Lets try creating a page to add a recipe to our database using a Server Action.

Challenge 6 bonus: Server Actions
Lets try improving our form by adding Server Side Validation using Zod to define a schema our formData must conform to.
We should return any validation errors and render them alongside the relevant input using the useFormState react hook.
Another improvement we could make is by showing some sort of loading spinner & preventing double clicks. React supplies a useFormStatus hook that can help with this.
We could also refactor our Server Action to perform an upsert instead of a create incase client side javascript is disabled.
